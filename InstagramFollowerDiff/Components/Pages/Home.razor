@page "/"
@inject NavigationManager _navigationManager
@inject IJSRuntime jsRuntime

<PageTitle>IGFollowBack</PageTitle>
<div class="holder bg-body">
    <h1>Instagram Follow Back Checker</h1>

    <p>Please upload an instagram data zip file, or a following and follower JSON file.</p>

    <div class="mb-3">
        <InputFile class="form-control form-control-lg" OnChange="@LoadFiles" multiple />
    </div>
    <p></p>

    @if (Error != null)
    {
        <p class="error">@Error</p>
    }
</div>

@if (NotFollowingBack.Count != 0)
{
    <p>@NotFollowingBack.Count not following back</p>
    <ul style="list-style-type: none; margin-left: -25px;">
        @for (int i = 0; i < NotFollowingBack.Count; i++)
        {
            var j = i;

            <li @onclick="(()=>Check(j))" style="margin-top: 5px;">
                <input class="form-check-input" type="checkbox" value="" id="checkbox-@i">
                &nbsp;
                <label class="form-check-label" for="flexCheckDefault" id="checkbox-label-@i">
                    @NotFollowingBack[i].User
                </label>
                <a id="href-@i" href="@NotFollowingBack[i].Link" style="visibility: none;"></a>
            </li>
        }
    </ul>
}
@code {
    public static readonly string JsonContentType = "application/json";
    public static readonly string ZipContentType = "application/zip";
    public static readonly string ZipContentType2 = "application/x-zip-compressed";
    private static readonly string[] AcceptedContentTypes = [JsonContentType, ZipContentType, ZipContentType2];
    public static readonly string JsonExtension = "json";
    public static readonly string ZipExtension = "zip";
    private static readonly string[] AcceptedExtensions = [JsonExtension, ZipExtension];

    private static readonly Regex ZipFileContentsFollowersRegex = new(@"^connections\/followers_and_following\/followers[^\/\.]*\.json$", RegexOptions.IgnoreCase);
    private static readonly Regex ZipFileContentsFollowingRegex = new(@"^connections\/followers_and_following\/following[^\/\.]*\.json$", RegexOptions.IgnoreCase);

    public static string FollowersDiffPath
    {
        get => Path.Combine(Path.GetTempPath(), "InstagramFollowerDiff");
    }

    private IBrowserFile? Following, Followers, Zip;

    string? Error;

    List<IGListItem> NotFollowingBack = [];

    private string? isDevice { get; set; }
    private bool mobile { get; set; }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        isDevice = await FindResponsiveness();
        Console.WriteLine(isDevice);
    }

    public async Task<string> FindResponsiveness()
    {
        mobile = await jsRuntime.InvokeAsync<bool>("isDevice");
        return mobile ? "Mobile" : "Desktop";

    }

    public async void Check(int i)
    {
        Nav(i);
        await jsRuntime.InvokeVoidAsync("checkCheckBox", i, "_blank");
    }

    public async void Nav(int i)
    {
        if (mobile)
            await jsRuntime.InvokeVoidAsync("clickHref", i, "_blank");
        else
            await jsRuntime.InvokeVoidAsync("open", NotFollowingBack[i].Link, "_blank");
    }

    private void Go()
    {
        Console.WriteLine("a");
    }

    private async void LoadFiles(InputFileChangeEventArgs e)
    {
        try
        {
            Zip = null;
            Following = null;
            Followers = null;
            Error = null;
            NotFollowingBack = [];

            CleanTemp();

            string temp = Path.Combine(FollowersDiffPath, Path.GetRandomFileName());
            string followersPath = temp + "-followers.json";
            string followingPath = temp + "-following.json";

            var files = e.GetMultipleFiles();

            foreach (var file in files)
            {
                Console.WriteLine(file.Name);

                var ext = Regex.Match(file.Name, @"(?<=\.)[^.]+$").Value;

                if (!AcceptedExtensions.Contains(ext) || !AcceptedContentTypes.Contains(file.ContentType))
                {
                    Console.WriteLine(file.Name + " not a valid file format.");
                    Error = file.Name + " not a valid file format.";
                    StateHasChanged();
                    return;
                }

                if (ext == ZipExtension)
                {
                    if (!file.Name.StartsWith("instagram-"))
                    {
                        Console.WriteLine("Please make sure the zip file was generated by instagram. It must start with \"instagram-\".");
                        Error = "Please make sure the zip file was generated by instagram. It must start with \"instagram-\".";
                        StateHasChanged();
                        return;
                    }
                    Zip = file;
                    Following = null;
                    Followers = null;
                    continue;
                }


                if (file.Name.ToLower().Contains("following"))
                    Following = file;
                else if (file.Name.ToLower().Contains("followers"))
                    Followers = file;
            }

            if (Zip == null)
            {
                if (Followers == null)
                {
                    Console.WriteLine("No followers file found.");
                    Error = "No followers file found.";
                    StateHasChanged();
                    return;
                }
                if (Following == null)
                {
                    Console.WriteLine("No following file found.");
                    Error = "No following file found.";
                    StateHasChanged();
                    return;
                }

                try
                {
                    await using (FileStream fs = new(followersPath, FileMode.Create))
                        await Followers.OpenReadStream(maxAllowedSize: 10000000).CopyToAsync(fs);
                    Console.WriteLine("Created " + followersPath);

                    await using (FileStream fs = new(followingPath, FileMode.Create))
                        await Following.OpenReadStream(maxAllowedSize: 10000000).CopyToAsync(fs);
                    Console.WriteLine("Created " + followingPath);
                }
                catch (IOException)
                {
                    Console.WriteLine("File(s) too large.");
                    Error = "File(s) too large.";
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                var zipPath = temp + ".zip";
                try
                {
                    await using (FileStream fs = new(zipPath, FileMode.Create))
                        await Zip.OpenReadStream(maxAllowedSize: 10000000).CopyToAsync(fs);
                }
                catch (IOException)
                {
                    Console.WriteLine("File(s) too large. Please make sure you requested \"Select types of information > Connections > Followers and following\" only.");
                    Error = "File(s) too large. Please make sure you requested \"Select types of information > Connections > Followers and following\" only.";
                    StateHasChanged();
                    return;
                }
                try
                {
                    using (ZipArchive archive = ZipFile.OpenRead(zipPath))
                    {
                        var followers = archive.Entries.Where(x => ZipFileContentsFollowersRegex.IsMatch(x.FullName)).FirstOrDefault();
                        var following = archive.Entries.Where(x => ZipFileContentsFollowingRegex.IsMatch(x.FullName)).FirstOrDefault();
                        if (followers == null)
                        {
                            Console.WriteLine("Followers file not found in zip archive");
                            Error = "Followers file not found in zip archive";
                            return;
                        }
                        if (following == null)
                        {
                            Console.WriteLine("Following file not found in zip archive");
                            Error = "Following file not found in zip archive";
                            return;
                        }

                        await using (FileStream fs = new(followersPath, FileMode.Create))
                            await followers.Open().CopyToAsync(fs);
                        Console.WriteLine("Created " + followersPath);

                        await using (FileStream fs = new(followingPath, FileMode.Create))
                            await following.Open().CopyToAsync(fs);
                        Console.WriteLine("Created " + followingPath);
                    }
                }
                catch
                {
                    Console.WriteLine("Error opening zip archive.");
                    Error = "Error opening zip archive.";
                    StateHasChanged();
                    return;
                }
            }

            List<Relationships>? followersRelationship, followingRelationships;
            List<IGListItem> followersList = [], followingList = [];
            try
            {
                using (StreamReader sr = new StreamReader(followersPath))
                {
                    string json = sr.ReadToEnd();
                    followersRelationship = JsonSerializer.Deserialize<List<Relationships>>(json);
                }
                if (followersRelationship == null)
                    throw new Exception();
                followersList = followersRelationship.Select(x => x.StringListData.FirstOrDefault()).ToList()!;
                if (followersList == null)
                    throw new Exception();
            }
            catch
            {
                Console.WriteLine("Unable to parse followers file.");
                Error = "Unable to parse followers file.";
                StateHasChanged();
                return;
            }
            try
            {
                using (StreamReader sr = new StreamReader(followingPath))
                {
                    string json = sr.ReadToEnd();
                    FollowingRoot? followingRoot = JsonSerializer.Deserialize<FollowingRoot>(json);
                    followingRelationships = followingRoot?.RelationshipsFollowing;
                }
                if (followingRelationships == null)
                    throw new Exception();
                followingList = followingRelationships.Select(x => x.StringListData.FirstOrDefault()).ToList()!;
                if (followingList == null)
                    throw new Exception();
            }
            catch
            {
                Console.WriteLine("Unable to parse following file.");
                Error = "Unable to parse following file.";
                StateHasChanged();
                return;
            }

            NotFollowingBack = followingList.ExceptBy(followersList.Select(x => x.User), x => x.User).ToList();

            StateHasChanged();

            CleanTemp();
        }
        catch (Exception error)
        {
            Console.WriteLine("Unhandled exception: " + error.Message);
            Error = "Unhandled exception: " + error.Message;
            StateHasChanged();
        }
    }

    private static void CleanTemp()
    {
        Directory.CreateDirectory(FollowersDiffPath);
        DirectoryInfo di = new DirectoryInfo(FollowersDiffPath);

        foreach (FileInfo file in di.GetFiles())
        {
            file.Delete();
        }
        foreach (DirectoryInfo dir in di.GetDirectories())
        {
            dir.Delete(true);
        }
    }
}